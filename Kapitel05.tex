\newchapter{Implementierung des Fehlerschätzers in Matlab}
\label{kap:5}

In diesem Kapitel wollen wir uns einen kurzen Überblick über den Quellcode für das programmierte Hindernis- bzw. Kontaktproblem verschaffen. Während wir an dieser Stelle einige wichtige Funktionen detailiert betrachten werden, können wir im Anhang \ref{anhang:D} den Matlab-Quellcode komplett einsehen.

In die Implementierung sind neben \cite{ZouVee} unter anderem auch Resultate aus \cite{MorNoc}, \cite{BarCar}, \cite{BraeFEM} und \cite{EPS} eingeflossen.


\section{Implementierung eines Hindernisproblems}
\label{kap:5.1}


\subsubsection{Grundlegender Aufbau des Programms}

In der Datei {\ttfamily start.m} werden die grundlegenden Daten für das betrachtete Beispiel festgelegt, wie beispielsweise
\begin{itemize}
\item die Geometriedaten für das Gitter und die Dirichlet-Randbedingungen,
\item die exakte Lösung des Funktionasl $J(u)$,
\item die Lastfunktion $f$ und
\item die initiale Triangulierung $\mcal T_0$.
\end{itemize}
Weiter werden nach Ausführung des adaptiven Algorithmus die Galerkin-Lösung und ein Fehlerdiagramm geplottet. 

Die Funktion {\ttfamily adaptive_refinement_solution.m} ist das Herzstück des Programms. Diese Datei beinhaltet den Ablauf des Algorithmus \ref{alg:4.1}, wobei hier die Abbruchbedingung aus Zeile 5 erweitert wurde. Alle weiteren Programmteile werden in {\ttfamily adaptive_refinement_solution.m} aufgerufen.


\subsubsection{Lokale Steifigkeitsmatrix und Assemblierung}

Wie schon in Kapitel \ref{kap:2.3} Beispiel \ref{bsp:2.26} beschrieben ist es für die Implementierung notwendig eine Verallgemeinerung zur Berechnung der Steifigkeitsmatrix herzuleiten. Die Idee ist an selber Stelle kurz vorgestellt worden; wir wollen nun angelehnt an Abbildung \ref{abb:2.5} die Formeln für die lokale Steifigkeitsmatrix eines beliebigen Elementes $T$ über das Referenzelement
\[
	\widetilde T = \{(\xi ,\eta)\in \R^2\mid 0\le \xi \le 1, 0\le \eta \le 1-\xi\}
\]
herleiten. Für die affine Transformation vom Referenzelement auf ein beliebiges Dreieck $T$ gelten die Bedingungen
\begin{subequations}\label{eq:5.1}
\begin{align}\label{eq:5.1a}
	x & = x_1 + (x_2-x_1)\xi + (x_3-x_1) \eta \, ,\\
	\label{eq:5.1b}
	y & = y_1 + (y_2-y_1)\xi + (y_3-y_1)\eta \, ,
\end{align}
\end{subequations}
wobei $(x_i,y_i),i=1,2,3,$ die Eckpunkte des Dreiecks $T$ sind (vgl. auch Abbildung \ref{abb:2.5}). Mit den Bedingungen \eqref{eq:5.1} erhalten wir dann die \idx{Funktionaldeterminante}
\begin{align}\label{eq:5.2}
\begin{aligned}
	J & = \det \begin{pmatrix}
				x_2-x_1 & x_3-x_1 \\
				y_2-y_1 & y_3-y_1
			\end{pmatrix}  \\
			& = (x_2-x_1)(y_3-y_1) - (x_3-x_1)(y_2-y_1)\, .
\end{aligned}
\end{align}
Dabei gilt $J>0$, da die Orientierung der Eckpunkte von $\widetilde T$ zu $T$ erhalten bleibt. Wir bezeichnen mit $\tilde u : \widetilde T \ra \R$ eine Funktion über dem Referenzdreieck und mit $u:T\ra \R$ die dazugehörige Funktion über dem allgemeinen Element $T$. Dann gilt zwischen $\tilde u $ und $u$ der Zusammenhang
\begin{align*}
	u(x,y) & = u(x_1 + (x_2-x_1)\xi + (x_3-x_1) \eta, y_1 + (y_2-y_1)\xi + (y_3-y_1)\eta) \\
	& =\tilde u(\xi,\eta) \, .
\end{align*}
Wir rechnen also unter Verwendung der \idx{Kettenregel} nach, dass
\begin{align*}
	\begin{pmatrix} \tilde u_\xi \\ \tilde u_\eta \end{pmatrix} & = \begin{pmatrix}
				x_2-x_1 & y_2-y_1 \\
				x_3-x_1 & y_3-y_1
			\end{pmatrix}   \begin{pmatrix}  u_x \\  u_y \end{pmatrix} \\
	\Llra  \begin{pmatrix}  u_x \\  u_y \end{pmatrix} & =\frac 1J \begin{pmatrix}
				y_3-y_1 & y_1-y_2 \\
				x_1-x_3 & x_2-x_1
			\end{pmatrix} \begin{pmatrix} \tilde u_\xi \\ \tilde u_\eta \end{pmatrix}
\end{align*}
gilt. Damit können wir $\nabla u \nabla v$ auf dem Referenzelement $\widetilde T$ ausdrücken durch
\begin{align*}
	\begin{pmatrix} u_x \\ u_y \end{pmatrix}^T \begin{pmatrix} v_x \\ v_y \end{pmatrix} & = \frac 1{J^2} \begin{pmatrix} \tilde u_\xi \\ \tilde u_\eta \end{pmatrix}^T \begin{pmatrix}
				y_3-y_1 & x_1-x_3 \\
				y_1-y_2 & x_2-x_1
			\end{pmatrix}  \begin{pmatrix}
				y_3-y_1 & y_1-y_2 \\
				x_1-x_3 & x_2-x_1
			\end{pmatrix}  \begin{pmatrix} \tilde v_\xi \\ \tilde v_\eta \end{pmatrix} \\
	& = \frac 1{J^2} \begin{pmatrix} \tilde u_\xi \\ \tilde u_\eta \end{pmatrix}^T     \begin{pmatrix}
				a & b \\
				b & c
			\end{pmatrix}    \begin{pmatrix} \tilde v_\xi \\ \tilde v_\eta \end{pmatrix} \\
	\text{mit }\qquad  & \!\!\!\!\!\!\!\!\!\!  \left\{ \begin{aligned}
			a & = (y_3-y_1)^2+ (x_3-x_1)^2 \\
			b  & = -( (y_3-y_1)(y_2-y_1) + (x_3-x_1)(x_2-x_1)) \\
			c & = (y_2-y_1)^2 + (x_2-x_1)^2
		\end{aligned} \right. \, .
\end{align*}

Insgesamt können wir nun die lokale Bilinearform $a_T(u,v)$ von einem allgemeinen Element $T$ auf das Referenzelement $\widetilde T$ transformieren.
\begin{align}\notag
	a_T (u,v) &\coloneqq \int_T \nabla u \nabla v \, dx dy= \int_T u_xv_x + u_yv_y \, dxdxdy \\
	\notag
	& = \int_{\widetilde T} \frac 1{J^2} (a\, \tilde u_\xi \tilde v_\xi + b\, (\tilde u_\xi \tilde v_\eta + \tilde u_\eta \tilde v_\xi) + c\,  \tilde u_\eta \tilde v_\eta ) J \, d\xi d\eta \\
	\notag
	& = \frac 1J \int_{\widetilde T} a\, \tilde u_\xi \tilde v_\xi + b\, (\tilde u_\xi \tilde v_\eta + \tilde u_\eta \tilde v_\xi) + c\,  \tilde u_\eta \tilde v_\eta  \, d\xi d\eta \\
	\label{eq:5.3}
	& = \frac 1J (a \, S_1 + b \, S_2 + c \, S_3)
\end{align}
Die Matrizen $S_k,k=1,2,3$, beinhalten dann die Anteile der einzelnen Summanden des Integranden aus dem oberen Integral von den jeweiligen lokalen Ansatzfunktionen. Eine Basis der linearen Ansatzfunktionen ist auf dem Referenzelement $\widetilde T$ beispielsweise von der Form
\begin{align}\label{eq:5.4}
	& \varphi_1(\xi,\eta) = 1-\xi-\eta \, ,\quad \varphi_2(\xi,\eta) = \xi \, , \quad \varphi_3(\xi,\eta) = \eta \, .
\end{align}
Damit lassen sich die Einträge von $S_1 \eqqcolon S = (s_{ij})_{i,j=1,2,3}$ berechnen durch
\begin{align}\label{eq:5.5}
	s_{ij} = \int_{\widetilde T} \varphi_{i,\xi} \, \varphi_{j,\xi} \, d\xi d\eta \, ,
\end{align}
d.h. mit \eqref{eq:5.4} berechnen wir die Gradienten
\begin{align*}
	  \nabla \varphi_1(\xi,\eta) = (-1,-1) \, , \quad \nabla \varphi_2(\xi,\eta) = (1,0) \, , \quad \nabla \varphi_3(\xi,\eta) = (0,1)
\end{align*}
und damit ergibt sich beispielsweise
\[
	s_{11} = \int_0^1 \int_0^{1-\xi} \varphi_{1,\xi} \, \varphi_{1,\xi} \, d\eta d\xi = \int_0^1 \int_0^{1-\xi} d\eta d\xi = \frac 12 \, .
\]
Analog lassen sich mit \eqref{eq:5.5} die weiteren Matrixeinträge aus $S_1$ berechnen bzw. mit \eqref{eq:5.3} und den dazugehörigen Formeln auch $S_2$ und $S_3$:
\begin{align*}
	S_1 = \begin{pmatrix}
				\frac 12 & -\frac 12 & 0 \\
				-\frac 12 & \frac 12 & 0 \\
				0 & 0 & 0
			\end{pmatrix} , \quad 
			S_2 = \begin{pmatrix}
				 1 & -\frac 12 & -\frac 12 \\
				-\frac 12 & 0 & \frac 12 \\
				-\frac 12 & \frac 12 & 0
			\end{pmatrix} , \quad 
			S_3 = \begin{pmatrix}
				\frac 12 & 0 & -\frac 12 \\
				0 & 0 & 0 \\
				-\frac 12 & 0 & \frac 12
			\end{pmatrix} .
\end{align*}
Insgesamt ist dann mit \eqref{eq:5.3} die lokale Steifigkeitsmatrix für die linearen Ansatzfunktionen eines beliebigen Elementes gegeben durch
\begin{align*}
	S = \frac 1{2J}\begin{pmatrix}
				a+2b+c & -a-b & -b-c \\
				-a-b & a & b \\
				-b-c & b & c
			\end{pmatrix}.
\end{align*}

Betrachten wir nun eine Basis von quadratischen Ansatzfunktionen auf $\widetilde T$, d.h.
\[
	\varphi_4(\xi,\eta) = 4\xi \, (1-\xi-\eta) \, , \quad \varphi_5(\xi,\eta) = 4\xi\eta \, , \quad \varphi_6(\xi,\eta) = 4\eta\, (1-\xi-\eta) \, ,
\]
dann können wir auch für diese nach Berechnung der Gradienten mit \eqref{eq:5.3}, \eqref{eq:5.5} und den analog resultierenden Formeln eine lokale Steifigkeitsmatrix $\bar S$ aufstellen. Diese hat dann die Form
\[
	\bar S  = \frac 4{3J}\begin{pmatrix}
				a+b+c & -b-c & b \\
				-b-c & a+b+c & -a-b \\
				b & -a-b & a+b+c
			\end{pmatrix}.
\]

Um das lokale Defektproblem \eqref{eq:4.9} zu lösen, ist nicht nur das Aufstellen von Steifigkeitsmatrizen über quadratische Ansatzfunktionen notwendig, sondern auch das Berechnen der rechten Seite $\rho_{\mcal S}(v) = (f,v)-a(u_{\mcal S},v)$. Auch hier können wir für zumindest einen Teil der Summe einen lokalen Vektor bestimmen. Analog zu \eqref{eq:5.3} rechnen wir nach, dass
\begin{align}\notag
	a_T(u_{\mcal S},v) & = \int_T \nabla u_{\mcal S} \nabla v \, dx dy \\
	\notag
	& = \int_{\widetilde T} (a\, \tilde u_{\mcal S,\xi} + b \, \tilde u_{\mcal S,\eta})\tilde v_\xi + (b\,  \tilde u_{\mcal S,\xi}+ c \, \tilde u_{\mcal S,\eta}) \tilde v_\eta \, d\xi d\eta \\
	\label{eq:5.6}
	& = \lambda \, \bs w_1 + \mu \, \bs w_2 
\end{align}
gilt, wobei $\bs w_i,i = 1,2$ Vektoren sind, deren Einträge gerade die lokalen Anteile an dem $i$-ten Summanden des Integranden bzgl. der quadratischen Ansatzfunktionen enthalten, analog zu den Matrizen $S_k$. Wenn wir also eine Lösung $u(x,y) = \alpha x+\beta y + \gamma$ auf $T$ gegeben haben, der Gradient $\nabla u(x,y) = (\alpha,\beta)$ noch auf $\widetilde T$ zu transformieren. Mit der affine Transformation \eqref{eq:5.1} lässt sich leicht nachrechnen, dass dann
\[
	\nabla \tilde u_{\mcal S} (\xi,\eta) = (\alpha\, (x_2-x_1)+\beta \, (y_2-y_1), \alpha \, (x_3-x_1) + \beta \, (y_3-y_1)) \eqqcolon (\tilde \alpha, \tilde \beta)
\]
ist. Damit ist $\lambda = a\tilde \alpha + b \tilde\beta$ und $\mu = b \tilde \alpha + c \tilde \beta$. Die Werte $\alpha, \beta$ des Gradienten auf $T$ lassen sich durch die gegebenen Funktionswerte von $u_{\mcal S}$ an den Eckpunkten des Elementes $T$ berechnen, da $u_{\mcal S}$ auf $T$ linear ist. Dies wird in der Datei {\ttfamily grad_u.m} verwendet. Die Vektoren $\bs w_1,\bs w_2$ ergeben sich nun aus
\[
	\bs w_1 = \int_0^1\int_0^{1-\xi} \begin{pmatrix}
								\varphi_{4,\xi} \\
								\varphi_{5,\xi} \\
								\varphi_{6,\xi}
							\end{pmatrix} d\eta d\xi =  \begin{pmatrix}
								0 \\
								\frac 23 \\
								-\frac 23
							\end{pmatrix} \, , \quad 
							\bs w_2 =  \begin{pmatrix}
								-\frac 23 \\
								\frac 23 \\
								0
							\end{pmatrix} \, .
\]
Damit ist der lokale Vektor aus \eqref{eq:5.6} bzgl. eines beliebigen Dreiecks $T$ gegeben durch
\[
	\bar{\bs \rho} = \lambda \begin{pmatrix}
								0 \\
								\frac 23 \\
								-\frac 23
							\end{pmatrix}+\mu  \begin{pmatrix}
								-\frac 23 \\
								\frac 23 \\
								0
							\end{pmatrix} = \begin{pmatrix}
					-\frac 23 (b\, \tilde \alpha + c\, \tilde\beta) \\
								\frac 23 (a\, \tilde\alpha + b\, (\tilde \beta + \tilde \alpha) + c\, \tilde\beta) \\
								-\frac 23 (a\,  \tilde \alpha + b\,  \tilde \beta)
							\end{pmatrix}.
\]

Die hier hergeleiteten Formeln für die lokalen Steifigkeitsmatrizen bzw. Vektoren werden in {\ttfamily local_mat.m} verwendet und ermöglichen einerseits eine leichtere Implementierung, da wir nur über ein Element integrieren müssen, andererseits erzeugen sie aber auch einen schnelleren Programmcode, weil wir keine Integrationen mehr durchführen müssen, um die Steifigkeitsmatrizen aufzustellen.

Die globalen Steifigkeitsmatrizen erzeugen wir dann durch Assemblierung, d.h. wir berechnen für alle Elemente die lokalen Steifigkeitsmatrizen und ordnen mit dem global-local node ordering jedem globalen Knoten in einem Element den jeweils lokalen zu. Damit addieren wir in der globalen Steifigkeitsmatrix im zugehörigen Eintrag den jeweiligen lokalen Eintrag auf. Dieses Vorgehen wir im Programmcode {\ttfamily assemble.m} verwendet. Natürlich ist die Assemblierung für den globalen Vektor aus $\rho_{\mcal S}$ analog.


\subsubsection{Lösung der quadratischen Programme}

Wie wir in Anhang \ref{anhang:B} beschrieben können wir die konvexen quadratischen Programme, die sich durch Hindernis- oder Kontaktproblem erzeugen, mit dem \idx{Active-Set-Algorithmus} lösen. Dieser ist unter anderem in der Matlab-Funktion {\ttfamily quadprog} hinterlegt. Allerdings ist der Active-Set-Algorithmus mit steigender Dimension schnell sehr langsam. Das Funktionen-Paket {\ttfamily quadprog} beinhaltet jedoch auch die \textit{\idx{Innere-Punkte-Methode}} (kurz: IPM), welche für große Systeme wesentlich schneller ist als die Active-Set-Methode. Daher verwenden wir die IPM zur Lösung der quadratischen Programme. Außerdem verwenden wir dazu \textit{Sparse}-Matrizen und die Option \textit{large-scale}, um die Auswertung zu beschleunigen.


\subsubsection{Quadratur auf einem Dreieck}


\subsubsection{Berechnung der einzelnen Knotenmengen}


\subsubsection{Berechnung des Normalenflußes}





\subsubsection{meine Stichpunkte}

\begin{itemize}
\item Gründe warum wo was.
\item Warum Verwendung von Sparse, IPM und large scale?
\end{itemize}



\newpage

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "Skript"
%%% End: 
